#include <stdio.h>
#include <string.h>

//   Reed–Solomon error correction code over the field F256
//   with parameters (255,255-2*t); t errors in 255-byte block will be fixed
//   ----------------------------------------------------------
//   Field F256 generated by the element al c minimal polynomial
//   al^8 + al^4 + al^3 + al^2 +  1.
//   ----------------------------------------------------------
//#include	 "vUtil.h"
#include     "rdso.h"
#define TMax	127	// the maximum number of corrected errors
typedef unsigned char      BYTE;

int     t = 25;				// the current number of corrected errors
int     t2 = 50;			// t2 = t*2                              
int     bufs = -1;			// current bufer size < 256           
BYTE    *c_buf;				// main bufes					
BYTE    c_s[TMax * 2 + 1];	// Syndrome

BYTE    c_g[TMax * 2 + 1] = {
	167,109,247,239,215,151,255,235, 62, 61, 47,151,190, 31,157,
 	 87,181, 60, 15,176,239,176,230, 46,162,102,230,157,135,159,
	 36,224,176,100,206,162,  8,156, 25,224,134,162,159,199, 58,
	198,209,213, 51,247,  1,  0,  0
};

BYTE    LAM1[TMax * 2 + 1], LAM2[TMax * 2 + 1];
// used in the Euclidean algorithm for finding the polynomial locator errors
BYTE    OMEGA1[TMax * 2 + 1], OMEGA2[TMax * 2 + 1];
int     dlam1, dlam2;		// degree of polynioms LAM1  (z) and LAM2  (z) 
int     dom1, dom2;			// degree of polynioms OMEGA1(z) and OMEGA2(z) 
BYTE    X[TMax * 2 + 1];	// error locators
BYTE    e[TMax * 2 + 1];	// error values

//	Table of logarithms and antilogarithms in the field F256
 BYTE C_log[256] = { // the reverse table to c_alog
	255,0  ,1  ,25 ,2  ,50 ,26 ,198,3  ,223,51 ,238,27 ,104,199,75 , //  0 
	4  ,100,224,14 ,52 ,141,239,129,28 ,193,105,248,200,8  ,76 ,113, //  1 
	5  ,138,101,47 ,225,36 ,15 ,33 ,53 ,147,142,218,240,18 ,130,69 , //  2 
	29 ,181,194,125,106,39 ,249,185,201,154,9  ,120,77 ,228,114,166, //  3 
	6  ,191,139,98 ,102,221,48 ,253,226,152,37 ,179,16 ,145,34 ,136, //  4 
	54 ,208,148,206,143,150,219,189,241,210,19 ,92 ,131,56 ,70 ,64 , //  5 
	30 ,66 ,182,163,195,72 ,126,110,107,58 ,40 ,84 ,250,133,186,61 , //  6 
	202,94 ,155,159,10 ,21 ,121,43 ,78 ,212,229,172,115,243,167,87 , //  7 
	7  ,112,192,247,140,128,99 ,13 ,103,74 ,222,237,49 ,197,254,24 , //  8 
	227,165,153,119,38 ,184,180,124,17 ,68 ,146,217,35 ,32 ,137,46 , //  9 
	55 ,63 ,209,91 ,149,188,207,205,144,135,151,178,220,252,190,97 , //  A 
	242,86 ,211,171,20 ,42 ,93 ,158,132,60 ,57 ,83 ,71 ,109,65 ,162, //  B 
	31 ,45 ,67 ,216,183,123,164,118,196,23 ,73 ,236,127,12 ,111,246, //  C 
	108,161,59 ,82 ,41 ,157,85 ,170,251,96 ,134,177,187,204,62 ,90 , //  D 
	203,89 ,95 ,176,156,169,160,81 ,11 ,245,22 ,235,122,117,44 ,215, //  E 
	79 ,174,213,233,230,231,173,232,116,214,244,234,168,80 ,88 ,175 };

 BYTE C_alog[256] = { // the degrees of element al
	    1,  2,  4,  8, 16, 32, 64,128, 29, 58,116,232,205,135, 19, 38, //  0 
	   76,152, 45, 90,180,117,234,201,143,  3,  6, 12, 24, 48, 96,192, //  1 
	  157, 39, 78,156, 37, 74,148, 53,106,212,181,119,238,193,159, 35, //  2 
	   70,140,  5, 10, 20, 40, 80,160, 93,186,105,210,185,111,222,161, //  3 
	   95,190, 97,194,153, 47, 94,188,101,202,137, 15, 30, 60,120,240, //  4 
	  253,231,211,187,107,214,177,127,254,225,223,163, 91,182,113,226, //  5 
	  217,175, 67,134, 17, 34, 68,136, 13, 26, 52,104,208,189,103,206, //  6 
	  129, 31, 62,124,248,237,199,147, 59,118,236,197,151, 51,102,204, //  7 
	  133, 23, 46, 92,184,109,218,169, 79,158, 33, 66,132, 21, 42, 84, //  8 
	  168, 77,154, 41, 82,164, 85,170, 73,146, 57,114,228,213,183,115, //  9 
	  230,209,191, 99,198,145, 63,126,252,229,215,179,123,246,241,255, //  A 
	  227,219,171, 75,150, 49, 98,196,149, 55,110,220,165, 87,174, 65, //  B 
	  130, 25, 50,100,200,141,  7, 14, 28, 56,112,224,221,167, 83,166, //  C 
	   81,162, 89,178,121,242,249,239,195,155, 43, 86,172, 69,138,  9, //  D 
	   18, 36, 72,144, 61,122,244,245,247,243,251,235,203,139, 11, 22, //  E 
	   44, 88,176,125,250,233,207,131, 27, 54,108,216,173, 71,142,  1 };

#define c_log(x)  (C_log [x])
#define c_alog(x) (C_alog[x])

#define c_mod255(x)     ((x)>254?(x)-255:(x))
#define c_mul(a,b) (a==0||b==0 ? 0 :c_alog(c_mod255((int)(c_log(a))+c_log(b))))

#define c_mulk(a,k) (a==0 ? 0 : c_alog(c_mod255(c_log(a)+k)))
#define c_revers(a) (c_alog(255-c_log(a)))

// -F-------------------- polynom clearing -------------------------- 
 void c_clear(BYTE *f, int maxdeg) {
	int i;
	for (i = 0; i <= maxdeg; i++) f[i] = 0;
}

// -F-------------- polynom degree ---------------------------------- 
 int c_degree(BYTE *f, int maxdeg) {
	int i, d;
	for (i = maxdeg, d = -1; i >= 0; i--)
		if (f[i]) { d = i; break; };
	return d;
}
// -F--------------  Syndrom calculation ------------------------ 
// Fill syndrom array c_s[0..t2-1] on buffer c_buf
 void c_sindrom(void) {
	int i, j, bi;
	BYTE bt;
	for (i = 0; i<t2; i++) c_s[i] = 0;
	for (i = 0; i<bufs; i++) {
		bt = c_buf[i];
		if (!bt) continue;
		c_s[0] ^= bt;
		bi = c_log(bt);
		for (j = 1; j<t2; j++) {
			bi += i; if (bi > 254) bi -= 255;
			c_s[j] ^= c_alog(bi);
		};
	};
}

// -F-------------- Coding -------------------------------------- 
// In positions t2..254  - information;
// 0 ..t2-1 - control bytes
// Information should be already prepared, the function c_code complement its control bytes.
// In c_buf[0..t2-1] store the remainder of dividing the code polynomial
// sum( i=t2..254; c_buf[i]*x^i ) by polynom  g(x).
void c_code0(void) {
	int  i, j;
	BYTE bt;
	for (i = 0; i<t2; i++) c_buf[i] = c_s[i] = 0;
	// ooooooooooooooooooooooooooooooooooooooooooo
	// s[0] + x*s[1] + ... + x^(t2-1)*s[t2-1]              --->
	// (x*s[0] + x^2*s[1] + ... + x^(t2-1)*s[t2-2] ) +
	// s[t2-1]*( g[0] + x*g[1] + ... + x^(t2-1)*g[t2-1] )
	// =
	// ( b[i] + g[0]*s[t2-1])     +
	// x       *( s[0] + g[1]*s[t2-1] )    +
	// x^2     *( s[1] + g[2]*s[t2-1] )    +
	// . . . .                 +
	// x^(t2-1)*( s[t2-2] + g[t2-1]*s[t2-1] )
	//ooooooooooooooooooooooooooooooooooooooooooo
	for (i = bufs - 1; i >= 0; i--) {
		bt = c_s[t2 - 1];
		for (j = t2 - 1; j>0; j--)
			c_s[j] = c_s[j - 1] ^ c_mul(c_g[j], bt);
		c_s[0] = c_buf[i] ^ c_mul(c_g[0], bt);
	};
	for (i = 0; i<t2; i++) c_buf[i] = c_s[i];
	// Now we'll find the syndrome for testing.
	// It should turn out to be equal to zero.
	//c_sindrom();
	//if( c_s[0] || c_s[1] )
	//herr( "illegal coding" );                  
}
// -F--------- swap LAM1 <--> LAM2 and rest -------------
void  c_swap(void) {
	BYTE co;
	int  i, te;
	if (dom1 < dom2) {
		for (i = 0; i <= t2; i++) {
			co = OMEGA1[i];
			OMEGA1[i] = OMEGA2[i];
			OMEGA2[i] = co;
		};
		for (i = 0; i <= t2; i++) {
			co = LAM1[i];
			LAM1[i] = LAM2[i];
			LAM2[i] = co;
		};
		te = dom1;  dom1 = dom2;  dom2 = te;
		te = dlam1; dlam1 = dlam2; dlam2 = te;
	}
}
/* -F---------------- One step of Euclid algorithm ---------------- *
    Let S(z) - a polynomial with coefficients s[ 0..t2-1 ],
    LAM1(z)    -            with coefficients LAM1[ 0..t ],
    LAM2(z)    -            with coefficients LAM2[ 0..t ],
    OMEGA1(z)  -            with coefficients OMEGA1[ 0..t2-1 ],
    OMEGA2(z)  -            with coefficients OMEGA2[ 0..t2-1 ].

    Should always be made of the  relations:
        S(z)*LAM1(z) = OMEGA1(z) mod z^t2 ,
        S(z)*LAM2(z) = OMEGA2(z) mod z^t2 ,
    In this case, senior coefficient of the polynomial is OMEGA1(z) and OMEGA2(z) 
	must be equal to 1 and dom1 >= dom2 (degree of the second polynomial does 
	not exceed the first degree).

    One step of the algorithm is the following:
    a)
        OMEGA1(z) := OMEGA1(z) - OMEGA2(z)*z^(dom1 - dom2);
        LAM1  (z) := LAM1  (z) - LAM2  (z)*z^(dom1 - dom2);
    b) compute the degrees of the polynomials dom1, dlam1.
    c) divide OMEGA1(z) and LAM1(z) by the oldest coefficient of the polynomial OMEGA1(z).
    d) If it is required, we swap the polynomials
        OMEGA1 <-->  OMEGA2 ,
        LAM1   <-->  LAM1   .
*/
void c_Evklid1(void) {
	int i;
	BYTE  co;
	for (i = 0; i <= dom2; i++)
		OMEGA1[i + dom1 - dom2] ^= OMEGA2[i];
	for (i = 0; i <= dom2; i++)
		LAM1[i + dom1 - dom2] ^= LAM2[i];
	dom1 = c_degree(OMEGA1, t2);
	dlam1 = c_degree(LAM1, t2);
	co = c_revers(OMEGA1[dom1]);

	for (i = 0; i <= dom1; i++)
		OMEGA1[i] = c_mul(OMEGA1[i], co);
	for (i = 0; i <= dlam1; i++)
		LAM1[i] = c_mul(LAM1[i], co);
	c_swap();
}

/* -F------------- Decoding ---------------------------------------
    The decoding algorithm is as follows.
    Let  Error locator polynomial equals:
        e(x)= e[1]*x^i[1] + ... + e[nu]*x^i[nu],
    where nu the number of errors, nu <= t,
    i[k] is a position of an error,
    e[k] value of the error.
    We denote by X[k] the number (from F256)  al^i[k].
    We define a syndromic power series
        S(z) = s[0] + s[1]*z + ....
    by formula:
                nu
        s[j] = SUM e[k]*al^( j*i[k] ).
               k=1
    Then
               infin         nu
        S(z) =  SUM   z^j * SUM e[k]*( (al^i[k])^j )  =
                j=0         k=1

                 nu        infin
                SUM e[k] *  SUM  z^j * X[k]^j         =
                k=1         j=0

                 nu             1
                SUM e[k] * -----------                =
                k=1         1 - z*X[k]


                 nu     e[k]
                SUM  ----------- .
                k=1  1 - z*X[k]

    The function c_sindrom calculate coefficients

	s[0], ... s[t2-1].
    
	Enter the error locator polynomial according to the formula

        LAM(z) = (1 - X[1]*z) * ... * (1 - X[nu]*z) =
                LAM[0] + LAM[1]*z + ... + LAM[nu]*z^nu .
    Then
                       nu
        S(z)*LAM(z) = SUM e[k]* PROD (1 - X[j]*z) .
                      k=1       j!=k

    This polynomial we denote by OMEGA(z), its degree <= nu-1.
    Our problem on the s[0], ... s[t2-1] find LAM[*], X[*], e[*].
    To find the polynomial LAM (z), note that in the polynomial
    OMEGA(z) = S(z)*LAM(z) the coefficients at z^nu, ..., z^(t2-1) equals to zero.
	After finding LAM(z), the error locators are found as the back values of the roots of the polynomial LAM(z).
    To find the values of erros, using the formula:

                OMEGA( 1/X[k] )
        e[k] =  --------------- * X[k].
                LAM' ( 1/X[k] )
*/
// -------- Function return the number of errors,
// If the returned -1, then the number of errors >t, and, therefore, we can not correct them
int c_decode0(void) {
	int i, j, k;
	BYTE co, co1;
	int degs;                   // degree of the polynom S(z) 
	int degs2;                  // next nonzero coefficient
	c_sindrom();                // find s[0], ... s[t2-1]
	degs = c_degree(c_s, t2 - 1);
	if (degs < 0) return 0;
	degs2 = c_degree(c_s, degs - 1);
	if (degs2< 0) return 0;				// If the polynom of errors of the form z^degs, then error
	c_clear(LAM1, t2 + 1);
	c_clear(LAM2, t2 + 1);
	c_clear(OMEGA1, t2 + 1);
	c_clear(OMEGA2, t2 + 1);
	// The initial value of the polynomial LAM1(z) is, up to the coefficient, z^(t2-degs)
	dlam1 = t2 - degs;
	dom1 = degs2 + dlam1;
	co = LAM1[dlam1] = c_revers(c_s[degs2]);
	for (i = 0; i <= degs2; i++)
		OMEGA1[i + dlam1] = c_mul(c_s[i], co);
	// The initial value of the polynom  LAM2(z) is constant
	dlam2 = 0;
	dom2 = degs;
	co = LAM2[0] = c_revers(c_s[degs]);
	for (i = 0; i <= degs; i++)
		OMEGA2[i] = c_mul(c_s[i], co);
	c_swap();
	//    LAM1, LAM2, OMEGA1, OMEGA2  is ready        
	while ((dom2 >= t) && (dlam2 <= t))
		c_Evklid1();
	// The polynoms LAM2 è OMEGA2 are ready.
	// If t >= dlam2 > dom2, then the number of errors equals to dlam2, 
	// otherwise, the number of errors> t, and therefore, we can not correct them.
	if (!(t >= dlam2 && dlam2 > dom2))
		return -1;
	// Zero can not be an error locator:
	if (!LAM2[0])
		return -1;
	// now calculate the errol locators X[..], that is the roots of LAM2(1/z)
	co = c_revers(LAM2[0]);
	for (i = 0; i <= dlam2; i++)
		LAM2[i] = c_mul(LAM2[i], co);
	for (i = 0; i <= dom2; i++)
		OMEGA2[i] = c_mul(OMEGA2[i], co);
	for (i = 0, j = 0; j < bufs; j++) {
		// test if al^j is a root of LAM2(1/z)       
		for (k = 1, co = LAM2[0]; k <= dlam2; k++)
			co = c_mulk(co, j) ^ LAM2[k];
		if (!co) {
			X[i] = j;
			i++;
			if (i >= dlam2) break;
		};
	};
	// If the number of roots less the degree of LAM2(z), then error:
	if (i<dlam2)
		return -1;
	// The locators of errors X[ 0..(dlam2-1) ] are finded.
	// It remains to find the error coefficients.
	for (i = 0; i < dlam2; i++) {
		j = 2 * (255 - X[i]);
		if (j > 255) j -= 255;
		for (k = dom2 - 1, co = OMEGA2[dom2]; k >= 0; k--)
			co = c_mulk(co, 255 - X[i]) ^ OMEGA2[k];
		// now co = OMEGA2( 1/X[i] ) 
		for (k = (dlam2 & (-2)) - 1, co1 = LAM2[k + 2]; k >= 0; k -= 2)
			co1 = c_mulk(co1, j) ^ LAM2[k];
		if (!co1) return -1;
		// now co1 = LAM2'( 1/X[i] )
		e[i] = c_mul(co, c_revers(co1));
		e[i] = c_mulk(e[i], X[i]);
		c_buf[X[i]] ^= e[i];
		// e[i] = co/co1
	};
	return dlam2;
}
// -F---------- the calculation of the polynomial ----
// g(x)=(x-1)*(x-al)*...*(x-al^t2) = x^t2 + g[t2-1]*x^(t2-1) + ... + g[1]*x + g[0]
// Returns 0 if OK, otherwise a negative number
int c_form(int NErr, int bufsize) {
	int i, j, t0=NErr;
	if (bufsize>255 || bufsize <3) return -1;
	bufs = bufsize;
	if (t0<0 || 2 * (t0 + 1) >= bufsize) return -1;
	if (t0>TMax) return -1;
	if (t == t0)                     return  0;
	t = t0;
	t2 = t * 2;
	c_clear(c_g, t2);
	c_g[0] = 1; c_g[1] = 1; c_g[2] = 0; // initial polynomial (x-1)   
	// In the next cycle the variable i is a current degree of polynom g.
	// On one step of the cycle from the polynomial (x-1)*...*(x-al^(i-1))
	// we obtain the polynomial                     (x-1)*...*(x-al^(i-1))*(x-al^i)
	for (i = 2; i <= t2; i++) {
		for (j = i; j>0; j--)
			c_g[j] = c_g[j - 1] ^ c_mulk(c_g[j], i - 1);
		c_g[0] = c_mulk(c_g[0], i - 1);
	};
	return 0;
}
// -F------------------------------------------------------------ 
// Assume that the original information is in bytes, 0..(bufs-t2-1). Move it to t2 bytes to the right.
void c_code(char *buf) {
	//int i;
	c_buf = (BYTE*)buf;
	memmove(c_buf + t2, c_buf, bufs - t2);
	c_code0();
}
// -F------------------------------------------------------------
//  The output must be bytes 0..(254-t2). So move it on t2 bytes to the left.
int c_decode(char *buf) {
	int i, nerr;
	c_buf = (BYTE*) buf;
	nerr = c_decode0();
	for (i = t2; i<bufs; i++) c_buf[i - t2] = c_buf[i];
	return nerr;
}
